/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "RendererJNI.h"
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <GLES3/gl3.h>
#include <android/asset_manager_jni.h>
#include <android/log.h>

#define LOG_TAG "ndk-build"
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
GLint g_programObject;
jint g_width;
jint g_height;

AAssetManager *g_pAssetManager = NULL;
GLuint shaderProgram[2];
GLuint VBOs[2];
GLuint VAOs[2];

char *readShaderSrcFile(char *shaderFile, AAssetManager *pAssetManager) {
    AAsset *pAsset = NULL;
    char *pBuffer = NULL;
    off_t size = -1;
    int numByte = -1;

    if (NULL == pAssetManager) {
        LOGE("pAssetManager is null!");
        return NULL;
    }
    pAsset = AAssetManager_open(pAssetManager, shaderFile, AASSET_MODE_UNKNOWN);
    //LOGI("after AAssetManager_open");

    size = AAsset_getLength(pAsset);
    LOGI("after AAssetManager_open");
    pBuffer = (char *) malloc(size + 1);
    pBuffer[size] = '\0';

    numByte = AAsset_read(pAsset, pBuffer, size);
    LOGI("%s : [%s]", shaderFile, pBuffer);
    AAsset_close(pAsset);

    return pBuffer;
}


GLuint LoadShader(GLenum type, const char *shaderSrc) {
    GLuint shader;
    GLint compiled;

    // Create the shader object
    shader = glCreateShader(type);

    if (shader == 0) {
        return 0;
    }

    // Load the shader source
    glShaderSource(shader, 1, &shaderSrc, NULL);

    // Compile the shader
    glCompileShader(shader);

    // Check the compile status
    glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);

    if (!compiled) {
        GLint infoLen = 0;

        glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &infoLen);

        if (infoLen > 1) {
            char *infoLog = (char *) malloc(sizeof(char) * infoLen);
            glGetShaderInfoLog(shader, infoLen, NULL, infoLog);
            LOGE("Error compiling shader:[%s]", infoLog);
            free(infoLog);
        }

        glDeleteShader(shader);
        return 0;
    }

    return shader;

}

/*
 * Class:     opengl_panjq_com_opengl_demo_RendererJNI
 * Method:    glesRender
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_opengl_panjq_com_opengl_1demo_RendererJNI_glesRender
        (JNIEnv *pEnv, jobject obj) {
    GLfloat vVertices[] = {0.0f, 0.5f, 0.0f,
                           -0.5f, -0.5f, 0.0f,
                           0.5f, -0.5f, 0.0f
    };
    GLuint VBO;
    glGenBuffers(1, &VBO);  //为VBO分配空间
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vVertices), vVertices, GL_STATIC_DRAW);

    // Set the viewport
    glViewport(0, 0, g_width, g_height);

    // Clear the color buffer
    glClear(GL_COLOR_BUFFER_BIT);

    // Use the program object
    glUseProgram(g_programObject);

    //数据的偏移量，数据的数量，数据的类型，是否取0-1之间，步长（0表示由gl自己决定）
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) 0);
    glEnableVertexAttribArray(0);

    glDrawArrays(GL_TRIANGLES, 0, 3);

}

/*
 * Class:     opengl_panjq_com_opengl_demo_RendererJNI
 * Method:    glesResize
 * Signature: (II)V
 */
JNIEXPORT void JNICALL Java_opengl_panjq_com_opengl_1demo_RendererJNI_glesResize
        (JNIEnv *pEnv, jobject obj, jint width, jint height) {
    g_width = width;
    g_height = height;

}

extern "C"
JNIEXPORT void JNICALL
Java_opengl_panjq_com_opengl_1demo_RendererJNI_glesTwoColorTriangle(JNIEnv *env, jobject instance) {
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(shaderProgram[0]);
    glBindVertexArray(VAOs[0]);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    glUseProgram(shaderProgram[1]);
    glBindVertexArray(VAOs[1]);
    glDrawArrays(GL_TRIANGLES, 0, 3);

}extern "C"
JNIEXPORT void JNICALL
Java_opengl_panjq_com_opengl_1demo_RendererJNI_glesInitTwoColor(JNIEnv *env, jobject instance) {
    GLfloat triangle0[9] = {
            //第一个三角形
            .5f, .5f, .0f,//右上
            -.5f, .5f, .0f,//左上
            .5f, -.5f, .0f,//右下
    };

    GLfloat triangle1[9] = {
            //第二个三角形
            -.5f, -.5f, .0f,//左下
            -.5f, .5f, .0f,//左上
            .5f, -.5f, .0f,//右下
    };


    glGenBuffers(2, VBOs);
    glGenVertexArrays(2, VAOs);

    glBindVertexArray(VAOs[0]);
    glBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(triangle0), triangle0, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);
    glEnableVertexAttribArray(0);

    glBindVertexArray(VAOs[1]);
    glBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(triangle1), triangle1, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void *) 0);
    glEnableVertexAttribArray(0);

}extern "C"
JNIEXPORT void JNICALL
Java_opengl_panjq_com_opengl_1demo_RendererJNI_readShaderFileTwoColor(JNIEnv *env, jobject instance,
                                                                      jobject assetManager) {

    if (assetManager && env) {
        //LOGI("before AAssetManager_fromJava");
        g_pAssetManager = AAssetManager_fromJava(env, assetManager);
        //LOGI("after AAssetManager_fromJava");
        if (NULL == g_pAssetManager) {
            LOGE("AAssetManager_fromJava() return null !");
            return;
        }
        GLuint vertexShader;
        GLuint fragmentShader[2];

        vertexShader = glCreateShader(GL_VERTEX_SHADER);
        GLchar *vertexSource = readShaderSrcFile(const_cast<char *>("shader/vs.glsl"),
                                                 g_pAssetManager);
        glShaderSource(vertexShader, 1, &vertexSource, nullptr);
        glCompileShader(vertexShader);

        fragmentShader[0] = glCreateShader(GL_FRAGMENT_SHADER);
        GLchar *temp = readShaderSrcFile(const_cast<char *>("shader/fs.glsl"), g_pAssetManager);
        glShaderSource(fragmentShader[0], 1, &temp, nullptr);
        glCompileShader(fragmentShader[0]);

        fragmentShader[1] = glCreateShader(GL_FRAGMENT_SHADER);
        temp = readShaderSrcFile(const_cast<char *>("shader/fs2.glsl"), g_pAssetManager);
        glShaderSource(fragmentShader[1], 1, &temp, nullptr);
        glCompileShader(fragmentShader[1]);

        shaderProgram[0] = glCreateProgram();
        glAttachShader(shaderProgram[0], vertexShader);
        glAttachShader(shaderProgram[0], fragmentShader[0]);
        glLinkProgram(shaderProgram[0]);

        shaderProgram[1] = glCreateProgram();
        glAttachShader(shaderProgram[1], vertexShader);
        glAttachShader(shaderProgram[1], fragmentShader[1]);
        glLinkProgram(shaderProgram[1]);

    } else {
        LOGE("assetManager is null !");
    }
}